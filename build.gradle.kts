import java.util.jar.JarFile
import java.util.stream.Collectors

/*
 * This file was generated by the Gradle 'init' task.
 */

plugins {
    application
    id("com.gradleup.shadow") version "8.3.5"
}

group = "canaryprism.mcwm"
version = "3.0.5"
description = "Minecraft World Manager"

application {
    mainModule = "canaryprism.mcwm"
    mainClass = "canaryprism.mcwm.Main"
}

java {
    toolchain.languageVersion = JavaLanguageVersion.of(22)
}

repositories {
    mavenCentral()
    mavenLocal()
}

dependencies {
    testImplementation(platform(libs.junit.bom))
    testImplementation(libs.junit.jupiter)

    implementation(libs.flatlaf)
    implementation(libs.commons.text)
    implementation(libs.commons.io)
    implementation(libs.commons.configuration2)
    implementation(libs.querz.nbt)
    implementation(libs.org.json.json)

    compileOnly(libs.jetbrains.annotations)

    implementation(libs.directories)

    runtimeOnly(libs.vfs2nio)
}

fun isModular(file: File): Boolean {
    return JarFile(file).getEntry("module-info.class") != null
}

val modular = application.mainModule.isPresent && configurations.runtimeClasspath.get()
    .files
    .stream()
    .allMatch { isModular(it) }

tasks.register<Copy>("gatherJars") {
    notCompatibleWithConfigurationCache("i don't really know")
    dependsOn(tasks.jar)
    if (modular) {
        from(configurations.runtimeClasspath, tasks.jar.get().archiveFile)
        into("build/release")
    } else {
        from(configurations.runtimeClasspath, tasks.jar.get().archiveFile)
        into("build/release/input")
    }
}

tasks.register("writeJPackageArgs") {
    notCompatibleWithConfigurationCache("i don't really know")
    dependsOn(tasks.jar)
    doLast {
        val jars = configurations.runtimeClasspath.get().files + setOf(tasks.jar.get().archiveFile.get().asFile)
        val file = file("build/release/args")
        file.writeText("""
            -n "${project.name}"
            --app-version "${project.version}"
            --description "${project.description}"
            ${if (modular) { 
                """
                    -p "${jars.stream().filter { isModular(it) }.map { it.name }
                            .collect(Collectors.joining(File.pathSeparator))}"
                    -m "${application.mainModule.get()}/${application.mainClass.get()}"
                """.trimIndent()
            } else {
                """
                    -i "input"
                    --main-jar ${tasks.jar.get().archiveFileName.get()}
                    --main-class ${application.mainClass.get()}
                    
                """.trimIndent()
            }}
        """.trimIndent())
    }
}

tasks.register("writeInfo") {
    notCompatibleWithConfigurationCache("i don't really know")
    doLast {
        val file = file("build/release/info.env")
        file.writeText("""
            NAME=${project.name}
            VERSION=${project.version}
        """.trimIndent())
    }
}

tasks.register("release") {
    notCompatibleWithConfigurationCache("i don't really know")
    dependsOn(tasks["gatherJars"], tasks["writeJPackageArgs"], tasks["writeInfo"])
}

tasks.shadowJar {
    mergeServiceFiles()
}

tasks.test {
    useJUnitPlatform()
}